{"version":3,"file":"next-redux-cookie-wrapper.esm.js","sources":["../src/config.ts","../src/util.ts","../src/cookies.ts","../src/state-walker.ts","../src/index.ts"],"sourcesContent":["import {CookieSerializeOptions} from \"cookie\";\nimport {Except, SetRequired} from \"type-fest\";\n\nexport type CookieOptions = Except<CookieSerializeOptions, \"encode\" | \"httpOnly\">;\n\nexport interface SubtreeConfig extends CookieOptions {\n\t/**\n\t * The path of a state subtree that shall be synced with cookies. If, for instance, the state\n\t * object is of the form\n\t * ```ts\n\t * {\n\t *   my: {\n\t *     config: {...},\n\t *   },\n\t *   otherState: {...},\n\t * }\n\t * ```\n\t * then some possible `subtree` values would be `my`, `my.config`, and `otherState`.\n\t */\n\tsubtree: string;\n\n\t/**\n\t * Whether or not to ignore a subtree's state in a state update from `getStaticProps()` (defaults\n\t * to `true`). If `false`, the state from `getStaticProps()` will be contained in the `HYDRATE`\n\t * action without any changes, leaving the merging up to the `HYDRATE` reducer. If `true`, the\n\t * received state from `getStaticProps()` will be replaced with the current client state before\n\t * the `HYDRATE` action is dispatched. This prevents the client's state from being reset to the\n\t * state from `getStaticProps()`.\n\t */\n\tignoreStateFromStaticProps?: boolean;\n\n\t/**\n\t * The name that will be assigned to the cookie that holds the subtree's state. Defaults to the\n\t * value of the {@link subtree} option.\n\t */\n\tcookieName?: string;\n\n\t/**\n\t * Whether or not to compress cookie values using lz-string. Defaults to `true`.\n\t */\n\tcompress?: boolean;\n}\n\nexport interface InternalSubtreeConfig\n\textends Except<\n\t\tSetRequired<SubtreeConfig, \"cookieName\" | \"ignoreStateFromStaticProps\" | \"compress\">,\n\t\tkeyof CookieOptions\n\t> {\n\tcookieOptions: CookieOptions;\n}\n\n/**\n * The configuration options for {@link nextReduxCookieMiddleware}. The {@link subtrees} option\n * specifies which subtrees of the state shall be synced with cookies, and how. It takes a list of\n * state subtree paths (e.g. `my.subtree`) or {@link SubtreeConfig} objects. All\n * {@link SubtreeConfig} options (except {@link SubtreeConfig.subtree} and\n * {@link SubtreeConfig.cookieName}) can also be set globally, making them the default for all\n * subtrees.\n *\n * @example\n * ```ts\n * {\n *   secure: true,\n *   subtrees: [\n *     \"my.first.subtree\",\n *     {subtree: \"subtree.two\"},\n *     {subtree: \"three\", secure: false},\n *   ]\n * }\n * ```\n * would set the `secure` option to `true` for the cookies of `my.first.subtree` and `subtree.two`,\n * but `false` for `three`.\n */\nexport interface NextReduxCookieMiddlewareConfig\n\textends Except<SubtreeConfig, \"subtree\" | \"cookieName\"> {\n\t/**\n\t * Specifies which subtrees of the state shall be synced with cookies, and how. Takes a list of\n\t * subtree paths (e.g. `my.subtree`) and/or {@link SubtreeConfig} objects.\n\t */\n\tsubtrees: Array<string | SubtreeConfig>;\n}\n\n/**\n * Given a `NextReduxCookieMiddlewareConfig` object, returns the corresponding list of\n * `InternalSubtreeConfig` objects.\n */\nexport function processMiddlewareConfig(\n\tconfig: NextReduxCookieMiddlewareConfig\n): InternalSubtreeConfig[] {\n\t// Set defaults and destructure the config object\n\tconst {subtrees, ...globalSubtreeConfig} = {\n\t\tignoreStateFromStaticProps: true,\n\t\tcompress: true,\n\t\tpath: \"/\",\n\t\tsameSite: true,\n\t\t...config,\n\t};\n\n\treturn (\n\t\tsubtrees\n\t\t\t// Turn strings into objects, set a default for the cookieName option, apply the global\n\t\t\t// default config, and extract cookie options into separate objects\n\t\t\t.map((current) => {\n\t\t\t\tif (typeof current === \"string\") {\n\t\t\t\t\tcurrent = {subtree: current};\n\t\t\t\t}\n\n\t\t\t\tconst {ignoreStateFromStaticProps, compress, subtree, cookieName, ...cookieOptions} = {\n\t\t\t\t\t...globalSubtreeConfig,\n\t\t\t\t\tcookieName: current.subtree,\n\t\t\t\t\t...current,\n\t\t\t\t};\n\t\t\t\treturn {\n\t\t\t\t\tignoreStateFromStaticProps,\n\t\t\t\t\tcompress,\n\t\t\t\t\tsubtree,\n\t\t\t\t\tcookieName,\n\t\t\t\t\tcookieOptions,\n\t\t\t\t};\n\t\t\t})\n\t);\n}\n","import {GetServerSidePropsContext, NextPageContext} from \"next\";\nimport {Context} from \"next-redux-wrapper\";\nimport {AppContext} from \"next/app\";\nimport {SetRequired} from \"type-fest\";\n\nexport const isClient = () => typeof window !== \"undefined\";\n\n/**\n * Returns whether the provided context is a `GetServerSidePropsContext` or a `PageContext` with\n * `req` and `res` set.\n */\nexport const isSsrContext = (\n\tcontext: Context\n): context is GetServerSidePropsContext | SetRequired<NextPageContext, \"req\" | \"res\"> =>\n\t(context as GetServerSidePropsContext).req !== undefined &&\n\t(context as GetServerSidePropsContext).res !== undefined;\n\n/**\n * Returns whether the provided context is an `AppContext`.\n */\nexport const isAppContext = (context: Context): context is AppContext =>\n\t(context as AppContext).ctx !== undefined;\n","import {compressToEncodedURIComponent, decompressFromEncodedURIComponent} from \"lz-string\";\nimport {GetServerSidePropsContext, NextPageContext} from \"next\";\nimport {parseCookies, setCookie} from \"nookies\";\nimport {JsonValue, SetRequired} from \"type-fest\";\n\nimport {InternalSubtreeConfig} from \"./config\";\nimport {isClient} from \"./util\";\n\nexport type Cookies = Record<string, JsonValue>;\n\nexport type CookieContext = SetRequired<\n\tPartial<GetServerSidePropsContext | NextPageContext>,\n\t\"req\" | \"res\"\n>;\n\nexport type CookieConfig = Pick<InternalSubtreeConfig, \"cookieName\" | \"compress\" | \"cookieOptions\">;\n\n/**\n * An isomorphic class to set and get (compressed) state cookies.\n */\nexport class StateCookies {\n\tprotected _config = new Map<string, CookieConfig>();\n\n\tprivate readonly _context?: CookieContext;\n\tprivate _cookies?: Cookies;\n\n\t/**\n\t * @param context The Next.js context for the request (if on the server)\n\t */\n\tconstructor(context?: CookieContext) {\n\t\tthis._context = context;\n\t}\n\n\tprivate static _encodeState(state: any) {\n\t\treturn encodeURIComponent(JSON.stringify(state));\n\t}\n\n\tprivate static _encodeStateCompressed(state: any) {\n\t\treturn compressToEncodedURIComponent(JSON.stringify(state));\n\t}\n\n\tprivate static _decodeState(state: string, compressed: boolean) {\n\t\treturn JSON.parse(\n\t\t\t(compressed ? decompressFromEncodedURIComponent : decodeURIComponent)(state)!\n\t\t);\n\t}\n\n\t/**\n\t * Set the configuration (@see CookieConfig) for each cookie\n\t */\n\tpublic setConfigurations(configurations: CookieConfig[]) {\n\t\tfor (const config of configurations) {\n\t\t\tthis._config.set(config.cookieName, config);\n\t\t}\n\t}\n\n\tpublic getAll() {\n\t\t// Parse cookies if they have not been parsed, always re-parse cookies on the client\n\t\tif (typeof this._cookies === \"undefined\" || isClient()) {\n\t\t\tthis._cookies = {};\n\t\t\tfor (const [name, value] of Object.entries(\n\t\t\t\tparseCookies(this._context, {decode: (value: string) => value})\n\t\t\t)) {\n\t\t\t\tconst config = this._config.get(name);\n\t\t\t\tif (config) {\n\t\t\t\t\tthis._cookies[name] = StateCookies._decodeState(value, config.compress);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._cookies;\n\t}\n\n\tpublic set(name: string, state: any) {\n\t\tconst {cookieOptions, compress} = this._config.get(name)!;\n\t\tsetCookie(this._context, name, state, {\n\t\t\t...cookieOptions,\n\t\t\tencode: compress ? StateCookies._encodeStateCompressed : StateCookies._encodeState,\n\t\t\thttpOnly: false,\n\t\t});\n\t}\n}\n","import {produce} from \"immer\";\nimport get from \"lodash/get\";\nimport set from \"lodash/set\";\nimport {JsonObject} from \"type-fest\";\n\nimport {InternalSubtreeConfig} from \"./config\";\n\n/**\n * Given a list of subtree configurations, two state objects `stateA` and `stateB`, and a walker\n * function, invokes the walker function for each `InternalSubtreeConfig` object. The walker\n * function receives a subtree config and the respective state subtrees from `stateA` and `stateB`.\n * If a subtree does not exist in a state object, `undefined` is passed instead.\n *\n * @param subtrees A list of `InternalSubtreeConfig` objects for the walker function\n * @param stateA First state object\n * @param stateB Optional second state object. If omitted the walker function will always receive\n * `undefined` as its last parameter.\n * @param walker A function that will be invoked for each `InternalSubtreeConfig` object from\n * `subtrees` with the `InternalSubtreeConfig` object and the respective state subtrees from\n * `stateA` and `stateB`.\n *\n * @returns A copy of `stateA` where those subtrees for which the walker function has returned a\n * value have been replaced by that value.\n */\nexport const walkState = <State extends JsonObject>(\n\tsubtrees: InternalSubtreeConfig[],\n\twalker: (\n\t\tsubtreeConfig: InternalSubtreeConfig,\n\t\tsubtreeA?: unknown,\n\t\tsubtreeB?: unknown\n\t) => unknown | undefined,\n\tstateA: State,\n\tstateB?: State\n) =>\n\t// @ts-ignore https://github.com/immerjs/immer/issues/839\n\tproduce(stateA, (draftState) => {\n\t\tfor (const subtreeConfig of subtrees) {\n\t\t\tconst {subtree} = subtreeConfig;\n\t\t\tconst result = walker(subtreeConfig, get(stateA, subtree), get(stateB, subtree));\n\t\t\tif (typeof result !== \"undefined\") {\n\t\t\t\tset(draftState, subtree, result);\n\t\t\t}\n\t\t}\n\t});\n","import isEqual from \"fast-deep-equal\";\nimport {Context, HYDRATE, MakeStore} from \"next-redux-wrapper\";\nimport {AnyAction, Middleware, Store} from \"redux\";\n\nimport {NextReduxCookieMiddlewareConfig, processMiddlewareConfig} from \"./config\";\nimport {StateCookies} from \"./cookies\";\nimport {walkState} from \"./state-walker\";\nimport {isAppContext, isClient, isSsrContext} from \"./util\";\n\nexport {NextReduxCookieMiddlewareConfig, SubtreeConfig} from \"./config\";\n\n/**\n * An action type that is dispatched internally on the server to pass the Next.js context to the\n * {@link nextReduxCookieMiddleware}.\n */\nexport const SERVE_COOKIES = \"next-redux-cookie-wrapper/SERVE_COOKIES\";\n\n/**\n * A tiny wrapper for the `makeStore()` function. It sends the received Next.js context to\n * {@link nextReduxCookieMiddleware} on the server via a {@link SERVE_COOKIES} action.\n *\n * Use it like this:\n * ```ts\n * export const wrapper = createWrapper<AppStore>(wrapMakeStore(makeStore));\n * ```\n *\n * @param makeStore The `makeStore()` function for `next-redux-wrapper`\n * @returns A wrapped version of the `makeStore()` function\n */\nexport const wrapMakeStore =\n\t<S extends Store>(makeStore: MakeStore<S>) =>\n\t(context: Context) => {\n\t\tconst store = makeStore(context);\n\n\t\tif (isClient()) {\n\t\t\t// Dispatch an empty HYDRATE action in case the current page doesn't have getServerSideProps,\n\t\t\t// getStaticProps, or getInitialProps and there are state cookies available. The middleware\n\t\t\t// will then add any state subtrees from cookies to the HYDRATE action's payload.\n\t\t\tstore.dispatch({type: HYDRATE, payload: {}});\n\t\t} else {\n\t\t\tif (isAppContext(context)) {\n\t\t\t\tcontext = context.ctx;\n\t\t\t}\n\n\t\t\tif (isSsrContext(context)) {\n\t\t\t\t// Create StateCookies object and smuggle it to the middleware via the `SERVE_COOKIES` action\n\t\t\t\tstore.dispatch({\n\t\t\t\t\ttype: SERVE_COOKIES,\n\t\t\t\t\tpayload: new StateCookies(context),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn store;\n\t};\n\n/**\n * A Redux middleware that syncs user-defined subtrees of the Redux state with cookies – on the\n * server and on the client. One cookie is used per state subtree and the serialized state is, by\n * default, compressed using [lz-string](https://github.com/pieroxy/lz-string). The subtree paths,\n * cookie names, cookie options, and compression are configured via a\n * {@link NextReduxCookieMiddlewareConfig} object.\n */\nexport const nextReduxCookieMiddleware: (config: NextReduxCookieMiddlewareConfig) => Middleware =\n\t(config) => (store) => {\n\t\tconst subtrees = processMiddlewareConfig(config);\n\n\t\tlet cookies: StateCookies;\n\t\tif (isClient()) {\n\t\t\tcookies = new StateCookies();\n\t\t\tcookies.setConfigurations(subtrees);\n\t\t}\n\t\t// On the server, we have to intercept the `SERVE_COOKIES` action to get the `cookies` object\n\t\t// (we cannot directly set a property on the store, sadly, since the middleware does not have\n\t\t// direct access to the store object).\n\n\t\treturn (next) => (action: AnyAction) => {\n\t\t\tswitch (action.type) {\n\t\t\t\tcase SERVE_COOKIES: {\n\t\t\t\t\t// Handle the SERVE_COOKIES action (server-only):\n\t\t\t\t\tcookies = action.payload;\n\t\t\t\t\tcookies.setConfigurations(subtrees);\n\t\t\t\t\t// Console.log(\"Cookies received by middleware\");\n\n\t\t\t\t\t// We have access to the client's cookies now. Now we need to hydrate the store with their\n\t\t\t\t\t// state.\n\t\t\t\t\tconst allCookies = cookies.getAll();\n\n\t\t\t\t\t// Console.log(\"Triggering initial HYDRATE\");\n\t\t\t\t\tstore.dispatch({\n\t\t\t\t\t\ttype: HYDRATE,\n\t\t\t\t\t\tpayload: walkState(subtrees, (subtree) => allCookies[subtree.cookieName], {}),\n\t\t\t\t\t});\n\n\t\t\t\t\t// We're done handling the action here (without calling `next()`).\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcase HYDRATE:\n\t\t\t\t\tif (isClient()) {\n\t\t\t\t\t\t// Intercept next-redux-wrapper's HYDRATE action on the client\n\n\t\t\t\t\t\tconst allCookies = cookies.getAll();\n\t\t\t\t\t\taction.payload = walkState(\n\t\t\t\t\t\t\tsubtrees,\n\t\t\t\t\t\t\t({ignoreStateFromStaticProps, cookieName}) => {\n\t\t\t\t\t\t\t\tif (ignoreStateFromStaticProps) {\n\t\t\t\t\t\t\t\t\t// `action.payload` holds the incoming server state. We overwrite that state with\n\t\t\t\t\t\t\t\t\t// the state from the cookies: If the incoming state is from getServerSideProps,\n\t\t\t\t\t\t\t\t\t// the cookies have also been updated to that state. If the incoming state is from\n\t\t\t\t\t\t\t\t\t// getStaticProps, the cookies have remained unchanged and hence the server's\n\t\t\t\t\t\t\t\t\t// state is ignored.\n\n\t\t\t\t\t\t\t\t\treturn allCookies[cookieName];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taction.payload\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t// Fall through to default handling of the `HYDRATE` action\n\n\t\t\t\tdefault: {\n\t\t\t\t\tconst oldState = store.getState();\n\t\t\t\t\tconst result = next(action);\n\t\t\t\t\tconst newState = store.getState();\n\n\t\t\t\t\t// If cookies are available (which is not the case during `getStaticProps()`), write the\n\t\t\t\t\t// new state into cookies wherever necessary\n\t\t\t\t\tif (cookies) {\n\t\t\t\t\t\twalkState(\n\t\t\t\t\t\t\tsubtrees,\n\t\t\t\t\t\t\t({cookieName}, oldSubtreeState, newSubtreeState) => {\n\t\t\t\t\t\t\t\tif (!isEqual(oldSubtreeState, newSubtreeState)) {\n\t\t\t\t\t\t\t\t\tcookies.set(cookieName, newSubtreeState);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toldState,\n\t\t\t\t\t\t\tnewState\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n"],"names":["processMiddlewareConfig","config","ignoreStateFromStaticProps","compress","path","sameSite","subtrees","globalSubtreeConfig","map","current","subtree","cookieName","cookieOptions","isClient","window","isSsrContext","context","req","undefined","res","isAppContext","ctx","StateCookies","Map","_context","_encodeState","state","encodeURIComponent","JSON","stringify","_encodeStateCompressed","compressToEncodedURIComponent","_decodeState","compressed","parse","decompressFromEncodedURIComponent","decodeURIComponent","setConfigurations","configurations","_config","set","getAll","_cookies","Object","entries","parseCookies","decode","value","name","get","setCookie","encode","httpOnly","walkState","walker","stateA","stateB","produce","draftState","subtreeConfig","result","SERVE_COOKIES","wrapMakeStore","makeStore","store","dispatch","type","HYDRATE","payload","nextReduxCookieMiddleware","cookies","next","action","allCookies","oldState","getState","newState","oldSubtreeState","newSubtreeState","isEqual"],"mappings":"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"}