import isEqual from 'fast-deep-equal';
import { HYDRATE } from 'next-redux-wrapper';
import { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from 'lz-string';
import { parseCookies, setCookie } from 'nookies';
import { produce } from 'immer';
import get from 'lodash-es/get';
import set from 'lodash-es/set';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * Given a `NextReduxCookieMiddlewareConfig` object, returns the corresponding list of
 * `InternalSubtreeConfig` objects.
 */
function processMiddlewareConfig(config) {
  // Set defaults and destructure the config object
  var _ignoreStateFromStati = _extends({
    ignoreStateFromStaticProps: true,
    compress: true,
    path: "/",
    sameSite: true
  }, config),
      subtrees = _ignoreStateFromStati.subtrees,
      globalSubtreeConfig = _objectWithoutPropertiesLoose(_ignoreStateFromStati, ["subtrees"]);

  return subtrees // Turn strings into objects, set a default for the cookieName option, apply the global
  // default config, and extract cookie options into separate objects
  .map(function (current) {
    if (typeof current === "string") {
      current = {
        subtree: current
      };
    }

    var _globalSubtreeConfig$ = _extends({}, globalSubtreeConfig, {
      cookieName: current.subtree
    }, current),
        ignoreStateFromStaticProps = _globalSubtreeConfig$.ignoreStateFromStaticProps,
        compress = _globalSubtreeConfig$.compress,
        subtree = _globalSubtreeConfig$.subtree,
        cookieName = _globalSubtreeConfig$.cookieName,
        cookieOptions = _objectWithoutPropertiesLoose(_globalSubtreeConfig$, ["ignoreStateFromStaticProps", "compress", "subtree", "cookieName"]);

    return {
      ignoreStateFromStaticProps: ignoreStateFromStaticProps,
      compress: compress,
      subtree: subtree,
      cookieName: cookieName,
      cookieOptions: cookieOptions
    };
  });
}

var isClient = function isClient() {
  return typeof window !== "undefined";
};
/**
 * Returns whether the provided context is a `GetServerSidePropsContext` or a `PageContext` with
 * `req` and `res` set.
 */

var isSsrContext = function isSsrContext(context) {
  return context.req !== undefined && context.res !== undefined;
};
/**
 * Returns whether the provided context is an `AppContext`.
 */

var isAppContext = function isAppContext(context) {
  return context.ctx !== undefined;
};

/**
 * An isomorphic class to set and get (compressed) state cookies.
 */

var StateCookies = /*#__PURE__*/function () {
  /**
   * @param context The Next.js context for the request (if on the server)
   */
  function StateCookies(context) {
    this._config = new Map();
    this._context = context;
  }

  StateCookies._encodeState = function _encodeState(state) {
    return encodeURIComponent(JSON.stringify(state));
  };

  StateCookies._encodeStateCompressed = function _encodeStateCompressed(state) {
    return compressToEncodedURIComponent(JSON.stringify(state));
  };

  StateCookies._decodeState = function _decodeState(state, compressed) {
    return JSON.parse((compressed ? decompressFromEncodedURIComponent : decodeURIComponent)(state));
  }
  /**
   * Set the configuration (@see CookieConfig) for each cookie
   */
  ;

  var _proto = StateCookies.prototype;

  _proto.setConfigurations = function setConfigurations(configurations) {
    for (var _iterator = _createForOfIteratorHelperLoose(configurations), _step; !(_step = _iterator()).done;) {
      var config = _step.value;

      this._config.set(config.cookieName, config);
    }
  };

  _proto.getAll = function getAll() {
    // Parse cookies if they have not been parsed, always re-parse cookies on the client
    if (typeof this._cookies === "undefined" || isClient()) {
      this._cookies = {};

      for (var _i = 0, _Object$entries = Object.entries(parseCookies(this._context, {
        decode: function decode(value) {
          return value;
        }
      })); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _Object$entries[_i],
            name = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        var config = this._config.get(name);

        if (config) {
          this._cookies[name] = StateCookies._decodeState(value, config.compress);
        }
      }
    }

    return this._cookies;
  };

  _proto.set = function set(name, state) {
    var _this$_config$get = this._config.get(name),
        cookieOptions = _this$_config$get.cookieOptions,
        compress = _this$_config$get.compress;

    setCookie(this._context, name, state, _extends({}, cookieOptions, {
      encode: compress ? StateCookies._encodeStateCompressed : StateCookies._encodeState,
      httpOnly: false
    }));
  };

  return StateCookies;
}();

/**
 * Given a list of subtree configurations, two state objects `stateA` and `stateB`, and a walker
 * function, invokes the walker function for each `InternalSubtreeConfig` object. The walker
 * function receives a subtree config and the respective state subtrees from `stateA` and `stateB`.
 * If a subtree does not exist in a state object, `undefined` is passed instead.
 *
 * @param subtrees A list of `InternalSubtreeConfig` objects for the walker function
 * @param stateA First state object
 * @param stateB Optional second state object. If omitted the walker function will always receive
 * `undefined` as its last parameter.
 * @param walker A function that will be invoked for each `InternalSubtreeConfig` object from
 * `subtrees` with the `InternalSubtreeConfig` object and the respective state subtrees from
 * `stateA` and `stateB`.
 *
 * @returns A copy of `stateA` where those subtrees for which the walker function has returned a
 * value have been replaced by that value.
 */

var walkState = function walkState(subtrees, walker, stateA, stateB) {
  return (// @ts-ignore https://github.com/immerjs/immer/issues/839
    produce(stateA, function (draftState) {
      for (var _iterator = _createForOfIteratorHelperLoose(subtrees), _step; !(_step = _iterator()).done;) {
        var subtreeConfig = _step.value;
        var subtree = subtreeConfig.subtree;
        var result = walker(subtreeConfig, get(stateA, subtree), get(stateB, subtree));

        if (typeof result !== "undefined") {
          set(draftState, subtree, result);
        }
      }
    })
  );
};

/**
 * An action type that is dispatched internally on the server to pass the Next.js context to the
 * {@link nextReduxCookieMiddleware}.
 */

var SERVE_COOKIES = "next-redux-cookie-wrapper/SERVE_COOKIES";
/**
 * A tiny wrapper for the `makeStore()` function. It sends the received Next.js context to
 * {@link nextReduxCookieMiddleware} on the server via a {@link SERVE_COOKIES} action.
 *
 * Use it like this:
 * ```ts
 * export const wrapper = createWrapper<AppStore>(wrapMakeStore(makeStore));
 * ```
 *
 * @param makeStore The `makeStore()` function for `next-redux-wrapper`
 * @returns A wrapped version of the `makeStore()` function
 */

var wrapMakeStore = function wrapMakeStore(makeStore) {
  return function (context) {
    var store = makeStore(context);

    if (isClient()) {
      // Dispatch an empty HYDRATE action in case the current page doesn't have getServerSideProps,
      // getStaticProps, or getInitialProps and there are state cookies available. The middleware
      // will then add any state subtrees from cookies to the HYDRATE action's payload.
      store.dispatch({
        type: HYDRATE,
        payload: {}
      });
    } else {
      if (isAppContext(context)) {
        context = context.ctx;
      }

      if (isSsrContext(context)) {
        // Create StateCookies object and smuggle it to the middleware via the `SERVE_COOKIES` action
        store.dispatch({
          type: SERVE_COOKIES,
          payload: new StateCookies(context)
        });
      }
    }

    return store;
  };
};
/**
 * A Redux middleware that syncs user-defined subtrees of the Redux state with cookies â€“ on the
 * server and on the client. One cookie is used per state subtree and the serialized state is, by
 * default, compressed using [lz-string](https://github.com/pieroxy/lz-string). The subtree paths,
 * cookie names, cookie options, and compression are configured via a
 * {@link NextReduxCookieMiddlewareConfig} object.
 */

var nextReduxCookieMiddleware = function nextReduxCookieMiddleware(config) {
  return function (store) {
    var subtrees = processMiddlewareConfig(config);
    var cookies;

    if (isClient()) {
      cookies = new StateCookies();
      cookies.setConfigurations(subtrees);
    } // On the server, we have to intercept the `SERVE_COOKIES` action to get the `cookies` object
    // (we cannot directly set a property on the store, sadly, since the middleware does not have
    // direct access to the store object).


    return function (next) {
      return function (action) {
        switch (action.type) {
          case SERVE_COOKIES:
            {
              // Handle the SERVE_COOKIES action (server-only):
              cookies = action.payload;
              cookies.setConfigurations(subtrees); // Console.log("Cookies received by middleware");
              // We have access to the client's cookies now. Now we need to hydrate the store with their
              // state.

              var allCookies = cookies.getAll(); // Console.log("Triggering initial HYDRATE");

              store.dispatch({
                type: HYDRATE,
                payload: walkState(subtrees, function (subtree) {
                  return allCookies[subtree.cookieName];
                }, {})
              }); // We're done handling the action here (without calling `next()`).

              return;
            }

          case HYDRATE:
            if (isClient()) {
              // Intercept next-redux-wrapper's HYDRATE action on the client
              var _allCookies = cookies.getAll();

              action.payload = walkState(subtrees, function (_ref) {
                var ignoreStateFromStaticProps = _ref.ignoreStateFromStaticProps,
                    cookieName = _ref.cookieName;

                if (ignoreStateFromStaticProps) {
                  // `action.payload` holds the incoming server state. We overwrite that state with
                  // the state from the cookies: If the incoming state is from getServerSideProps,
                  // the cookies have also been updated to that state. If the incoming state is from
                  // getStaticProps, the cookies have remained unchanged and hence the server's
                  // state is ignored.
                  return _allCookies[cookieName];
                }
              }, action.payload);
            }

          // Fall through to default handling of the `HYDRATE` action

          default:
            {
              var oldState = store.getState();
              var result = next(action);
              var newState = store.getState(); // If cookies are available (which is not the case during `getStaticProps()`), write the
              // new state into cookies wherever necessary

              if (cookies) {
                walkState(subtrees, function (_ref2, oldSubtreeState, newSubtreeState) {
                  var cookieName = _ref2.cookieName;

                  if (!isEqual(oldSubtreeState, newSubtreeState)) {
                    cookies.set(cookieName, newSubtreeState);
                  }
                }, oldState, newState);
              }

              return result;
            }
        }
      };
    };
  };
};

export { SERVE_COOKIES, nextReduxCookieMiddleware, wrapMakeStore };
//# sourceMappingURL=next-redux-cookie-wrapper.esm.js.map
