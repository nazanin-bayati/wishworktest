{"version":3,"file":"next-redux-cookie-wrapper.cjs.production.min.js","sources":["../src/util.ts","../src/cookies.ts","../src/state-walker.ts","../src/index.ts","../src/config.ts"],"sourcesContent":["import {GetServerSidePropsContext, NextPageContext} from \"next\";\nimport {Context} from \"next-redux-wrapper\";\nimport {AppContext} from \"next/app\";\nimport {SetRequired} from \"type-fest\";\n\nexport const isClient = () => typeof window !== \"undefined\";\n\n/**\n * Returns whether the provided context is a `GetServerSidePropsContext` or a `PageContext` with\n * `req` and `res` set.\n */\nexport const isSsrContext = (\n\tcontext: Context\n): context is GetServerSidePropsContext | SetRequired<NextPageContext, \"req\" | \"res\"> =>\n\t(context as GetServerSidePropsContext).req !== undefined &&\n\t(context as GetServerSidePropsContext).res !== undefined;\n\n/**\n * Returns whether the provided context is an `AppContext`.\n */\nexport const isAppContext = (context: Context): context is AppContext =>\n\t(context as AppContext).ctx !== undefined;\n","import {compressToEncodedURIComponent, decompressFromEncodedURIComponent} from \"lz-string\";\nimport {GetServerSidePropsContext, NextPageContext} from \"next\";\nimport {parseCookies, setCookie} from \"nookies\";\nimport {JsonValue, SetRequired} from \"type-fest\";\n\nimport {InternalSubtreeConfig} from \"./config\";\nimport {isClient} from \"./util\";\n\nexport type Cookies = Record<string, JsonValue>;\n\nexport type CookieContext = SetRequired<\n\tPartial<GetServerSidePropsContext | NextPageContext>,\n\t\"req\" | \"res\"\n>;\n\nexport type CookieConfig = Pick<InternalSubtreeConfig, \"cookieName\" | \"compress\" | \"cookieOptions\">;\n\n/**\n * An isomorphic class to set and get (compressed) state cookies.\n */\nexport class StateCookies {\n\tprotected _config = new Map<string, CookieConfig>();\n\n\tprivate readonly _context?: CookieContext;\n\tprivate _cookies?: Cookies;\n\n\t/**\n\t * @param context The Next.js context for the request (if on the server)\n\t */\n\tconstructor(context?: CookieContext) {\n\t\tthis._context = context;\n\t}\n\n\tprivate static _encodeState(state: any) {\n\t\treturn encodeURIComponent(JSON.stringify(state));\n\t}\n\n\tprivate static _encodeStateCompressed(state: any) {\n\t\treturn compressToEncodedURIComponent(JSON.stringify(state));\n\t}\n\n\tprivate static _decodeState(state: string, compressed: boolean) {\n\t\treturn JSON.parse(\n\t\t\t(compressed ? decompressFromEncodedURIComponent : decodeURIComponent)(state)!\n\t\t);\n\t}\n\n\t/**\n\t * Set the configuration (@see CookieConfig) for each cookie\n\t */\n\tpublic setConfigurations(configurations: CookieConfig[]) {\n\t\tfor (const config of configurations) {\n\t\t\tthis._config.set(config.cookieName, config);\n\t\t}\n\t}\n\n\tpublic getAll() {\n\t\t// Parse cookies if they have not been parsed, always re-parse cookies on the client\n\t\tif (typeof this._cookies === \"undefined\" || isClient()) {\n\t\t\tthis._cookies = {};\n\t\t\tfor (const [name, value] of Object.entries(\n\t\t\t\tparseCookies(this._context, {decode: (value: string) => value})\n\t\t\t)) {\n\t\t\t\tconst config = this._config.get(name);\n\t\t\t\tif (config) {\n\t\t\t\t\tthis._cookies[name] = StateCookies._decodeState(value, config.compress);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._cookies;\n\t}\n\n\tpublic set(name: string, state: any) {\n\t\tconst {cookieOptions, compress} = this._config.get(name)!;\n\t\tsetCookie(this._context, name, state, {\n\t\t\t...cookieOptions,\n\t\t\tencode: compress ? StateCookies._encodeStateCompressed : StateCookies._encodeState,\n\t\t\thttpOnly: false,\n\t\t});\n\t}\n}\n","import {produce} from \"immer\";\nimport get from \"lodash/get\";\nimport set from \"lodash/set\";\nimport {JsonObject} from \"type-fest\";\n\nimport {InternalSubtreeConfig} from \"./config\";\n\n/**\n * Given a list of subtree configurations, two state objects `stateA` and `stateB`, and a walker\n * function, invokes the walker function for each `InternalSubtreeConfig` object. The walker\n * function receives a subtree config and the respective state subtrees from `stateA` and `stateB`.\n * If a subtree does not exist in a state object, `undefined` is passed instead.\n *\n * @param subtrees A list of `InternalSubtreeConfig` objects for the walker function\n * @param stateA First state object\n * @param stateB Optional second state object. If omitted the walker function will always receive\n * `undefined` as its last parameter.\n * @param walker A function that will be invoked for each `InternalSubtreeConfig` object from\n * `subtrees` with the `InternalSubtreeConfig` object and the respective state subtrees from\n * `stateA` and `stateB`.\n *\n * @returns A copy of `stateA` where those subtrees for which the walker function has returned a\n * value have been replaced by that value.\n */\nexport const walkState = <State extends JsonObject>(\n\tsubtrees: InternalSubtreeConfig[],\n\twalker: (\n\t\tsubtreeConfig: InternalSubtreeConfig,\n\t\tsubtreeA?: unknown,\n\t\tsubtreeB?: unknown\n\t) => unknown | undefined,\n\tstateA: State,\n\tstateB?: State\n) =>\n\t// @ts-ignore https://github.com/immerjs/immer/issues/839\n\tproduce(stateA, (draftState) => {\n\t\tfor (const subtreeConfig of subtrees) {\n\t\t\tconst {subtree} = subtreeConfig;\n\t\t\tconst result = walker(subtreeConfig, get(stateA, subtree), get(stateB, subtree));\n\t\t\tif (typeof result !== \"undefined\") {\n\t\t\t\tset(draftState, subtree, result);\n\t\t\t}\n\t\t}\n\t});\n","import isEqual from \"fast-deep-equal\";\nimport {Context, HYDRATE, MakeStore} from \"next-redux-wrapper\";\nimport {AnyAction, Middleware, Store} from \"redux\";\n\nimport {NextReduxCookieMiddlewareConfig, processMiddlewareConfig} from \"./config\";\nimport {StateCookies} from \"./cookies\";\nimport {walkState} from \"./state-walker\";\nimport {isAppContext, isClient, isSsrContext} from \"./util\";\n\nexport {NextReduxCookieMiddlewareConfig, SubtreeConfig} from \"./config\";\n\n/**\n * An action type that is dispatched internally on the server to pass the Next.js context to the\n * {@link nextReduxCookieMiddleware}.\n */\nexport const SERVE_COOKIES = \"next-redux-cookie-wrapper/SERVE_COOKIES\";\n\n/**\n * A tiny wrapper for the `makeStore()` function. It sends the received Next.js context to\n * {@link nextReduxCookieMiddleware} on the server via a {@link SERVE_COOKIES} action.\n *\n * Use it like this:\n * ```ts\n * export const wrapper = createWrapper<AppStore>(wrapMakeStore(makeStore));\n * ```\n *\n * @param makeStore The `makeStore()` function for `next-redux-wrapper`\n * @returns A wrapped version of the `makeStore()` function\n */\nexport const wrapMakeStore =\n\t<S extends Store>(makeStore: MakeStore<S>) =>\n\t(context: Context) => {\n\t\tconst store = makeStore(context);\n\n\t\tif (isClient()) {\n\t\t\t// Dispatch an empty HYDRATE action in case the current page doesn't have getServerSideProps,\n\t\t\t// getStaticProps, or getInitialProps and there are state cookies available. The middleware\n\t\t\t// will then add any state subtrees from cookies to the HYDRATE action's payload.\n\t\t\tstore.dispatch({type: HYDRATE, payload: {}});\n\t\t} else {\n\t\t\tif (isAppContext(context)) {\n\t\t\t\tcontext = context.ctx;\n\t\t\t}\n\n\t\t\tif (isSsrContext(context)) {\n\t\t\t\t// Create StateCookies object and smuggle it to the middleware via the `SERVE_COOKIES` action\n\t\t\t\tstore.dispatch({\n\t\t\t\t\ttype: SERVE_COOKIES,\n\t\t\t\t\tpayload: new StateCookies(context),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn store;\n\t};\n\n/**\n * A Redux middleware that syncs user-defined subtrees of the Redux state with cookies â€“ on the\n * server and on the client. One cookie is used per state subtree and the serialized state is, by\n * default, compressed using [lz-string](https://github.com/pieroxy/lz-string). The subtree paths,\n * cookie names, cookie options, and compression are configured via a\n * {@link NextReduxCookieMiddlewareConfig} object.\n */\nexport const nextReduxCookieMiddleware: (config: NextReduxCookieMiddlewareConfig) => Middleware =\n\t(config) => (store) => {\n\t\tconst subtrees = processMiddlewareConfig(config);\n\n\t\tlet cookies: StateCookies;\n\t\tif (isClient()) {\n\t\t\tcookies = new StateCookies();\n\t\t\tcookies.setConfigurations(subtrees);\n\t\t}\n\t\t// On the server, we have to intercept the `SERVE_COOKIES` action to get the `cookies` object\n\t\t// (we cannot directly set a property on the store, sadly, since the middleware does not have\n\t\t// direct access to the store object).\n\n\t\treturn (next) => (action: AnyAction) => {\n\t\t\tswitch (action.type) {\n\t\t\t\tcase SERVE_COOKIES: {\n\t\t\t\t\t// Handle the SERVE_COOKIES action (server-only):\n\t\t\t\t\tcookies = action.payload;\n\t\t\t\t\tcookies.setConfigurations(subtrees);\n\t\t\t\t\t// Console.log(\"Cookies received by middleware\");\n\n\t\t\t\t\t// We have access to the client's cookies now. Now we need to hydrate the store with their\n\t\t\t\t\t// state.\n\t\t\t\t\tconst allCookies = cookies.getAll();\n\n\t\t\t\t\t// Console.log(\"Triggering initial HYDRATE\");\n\t\t\t\t\tstore.dispatch({\n\t\t\t\t\t\ttype: HYDRATE,\n\t\t\t\t\t\tpayload: walkState(subtrees, (subtree) => allCookies[subtree.cookieName], {}),\n\t\t\t\t\t});\n\n\t\t\t\t\t// We're done handling the action here (without calling `next()`).\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcase HYDRATE:\n\t\t\t\t\tif (isClient()) {\n\t\t\t\t\t\t// Intercept next-redux-wrapper's HYDRATE action on the client\n\n\t\t\t\t\t\tconst allCookies = cookies.getAll();\n\t\t\t\t\t\taction.payload = walkState(\n\t\t\t\t\t\t\tsubtrees,\n\t\t\t\t\t\t\t({ignoreStateFromStaticProps, cookieName}) => {\n\t\t\t\t\t\t\t\tif (ignoreStateFromStaticProps) {\n\t\t\t\t\t\t\t\t\t// `action.payload` holds the incoming server state. We overwrite that state with\n\t\t\t\t\t\t\t\t\t// the state from the cookies: If the incoming state is from getServerSideProps,\n\t\t\t\t\t\t\t\t\t// the cookies have also been updated to that state. If the incoming state is from\n\t\t\t\t\t\t\t\t\t// getStaticProps, the cookies have remained unchanged and hence the server's\n\t\t\t\t\t\t\t\t\t// state is ignored.\n\n\t\t\t\t\t\t\t\t\treturn allCookies[cookieName];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taction.payload\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t// Fall through to default handling of the `HYDRATE` action\n\n\t\t\t\tdefault: {\n\t\t\t\t\tconst oldState = store.getState();\n\t\t\t\t\tconst result = next(action);\n\t\t\t\t\tconst newState = store.getState();\n\n\t\t\t\t\t// If cookies are available (which is not the case during `getStaticProps()`), write the\n\t\t\t\t\t// new state into cookies wherever necessary\n\t\t\t\t\tif (cookies) {\n\t\t\t\t\t\twalkState(\n\t\t\t\t\t\t\tsubtrees,\n\t\t\t\t\t\t\t({cookieName}, oldSubtreeState, newSubtreeState) => {\n\t\t\t\t\t\t\t\tif (!isEqual(oldSubtreeState, newSubtreeState)) {\n\t\t\t\t\t\t\t\t\tcookies.set(cookieName, newSubtreeState);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toldState,\n\t\t\t\t\t\t\tnewState\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n","import {CookieSerializeOptions} from \"cookie\";\nimport {Except, SetRequired} from \"type-fest\";\n\nexport type CookieOptions = Except<CookieSerializeOptions, \"encode\" | \"httpOnly\">;\n\nexport interface SubtreeConfig extends CookieOptions {\n\t/**\n\t * The path of a state subtree that shall be synced with cookies. If, for instance, the state\n\t * object is of the form\n\t * ```ts\n\t * {\n\t *   my: {\n\t *     config: {...},\n\t *   },\n\t *   otherState: {...},\n\t * }\n\t * ```\n\t * then some possible `subtree` values would be `my`, `my.config`, and `otherState`.\n\t */\n\tsubtree: string;\n\n\t/**\n\t * Whether or not to ignore a subtree's state in a state update from `getStaticProps()` (defaults\n\t * to `true`). If `false`, the state from `getStaticProps()` will be contained in the `HYDRATE`\n\t * action without any changes, leaving the merging up to the `HYDRATE` reducer. If `true`, the\n\t * received state from `getStaticProps()` will be replaced with the current client state before\n\t * the `HYDRATE` action is dispatched. This prevents the client's state from being reset to the\n\t * state from `getStaticProps()`.\n\t */\n\tignoreStateFromStaticProps?: boolean;\n\n\t/**\n\t * The name that will be assigned to the cookie that holds the subtree's state. Defaults to the\n\t * value of the {@link subtree} option.\n\t */\n\tcookieName?: string;\n\n\t/**\n\t * Whether or not to compress cookie values using lz-string. Defaults to `true`.\n\t */\n\tcompress?: boolean;\n}\n\nexport interface InternalSubtreeConfig\n\textends Except<\n\t\tSetRequired<SubtreeConfig, \"cookieName\" | \"ignoreStateFromStaticProps\" | \"compress\">,\n\t\tkeyof CookieOptions\n\t> {\n\tcookieOptions: CookieOptions;\n}\n\n/**\n * The configuration options for {@link nextReduxCookieMiddleware}. The {@link subtrees} option\n * specifies which subtrees of the state shall be synced with cookies, and how. It takes a list of\n * state subtree paths (e.g. `my.subtree`) or {@link SubtreeConfig} objects. All\n * {@link SubtreeConfig} options (except {@link SubtreeConfig.subtree} and\n * {@link SubtreeConfig.cookieName}) can also be set globally, making them the default for all\n * subtrees.\n *\n * @example\n * ```ts\n * {\n *   secure: true,\n *   subtrees: [\n *     \"my.first.subtree\",\n *     {subtree: \"subtree.two\"},\n *     {subtree: \"three\", secure: false},\n *   ]\n * }\n * ```\n * would set the `secure` option to `true` for the cookies of `my.first.subtree` and `subtree.two`,\n * but `false` for `three`.\n */\nexport interface NextReduxCookieMiddlewareConfig\n\textends Except<SubtreeConfig, \"subtree\" | \"cookieName\"> {\n\t/**\n\t * Specifies which subtrees of the state shall be synced with cookies, and how. Takes a list of\n\t * subtree paths (e.g. `my.subtree`) and/or {@link SubtreeConfig} objects.\n\t */\n\tsubtrees: Array<string | SubtreeConfig>;\n}\n\n/**\n * Given a `NextReduxCookieMiddlewareConfig` object, returns the corresponding list of\n * `InternalSubtreeConfig` objects.\n */\nexport function processMiddlewareConfig(\n\tconfig: NextReduxCookieMiddlewareConfig\n): InternalSubtreeConfig[] {\n\t// Set defaults and destructure the config object\n\tconst {subtrees, ...globalSubtreeConfig} = {\n\t\tignoreStateFromStaticProps: true,\n\t\tcompress: true,\n\t\tpath: \"/\",\n\t\tsameSite: true,\n\t\t...config,\n\t};\n\n\treturn (\n\t\tsubtrees\n\t\t\t// Turn strings into objects, set a default for the cookieName option, apply the global\n\t\t\t// default config, and extract cookie options into separate objects\n\t\t\t.map((current) => {\n\t\t\t\tif (typeof current === \"string\") {\n\t\t\t\t\tcurrent = {subtree: current};\n\t\t\t\t}\n\n\t\t\t\tconst {ignoreStateFromStaticProps, compress, subtree, cookieName, ...cookieOptions} = {\n\t\t\t\t\t...globalSubtreeConfig,\n\t\t\t\t\tcookieName: current.subtree,\n\t\t\t\t\t...current,\n\t\t\t\t};\n\t\t\t\treturn {\n\t\t\t\t\tignoreStateFromStaticProps,\n\t\t\t\t\tcompress,\n\t\t\t\t\tsubtree,\n\t\t\t\t\tcookieName,\n\t\t\t\t\tcookieOptions,\n\t\t\t\t};\n\t\t\t})\n\t);\n}\n"],"names":["isClient","window","StateCookies","context","Map","_context","_encodeState","state","encodeURIComponent","JSON","stringify","_encodeStateCompressed","compressToEncodedURIComponent","_decodeState","compressed","parse","decompressFromEncodedURIComponent","decodeURIComponent","setConfigurations","configurations","config","_config","set","cookieName","getAll","this","_cookies","Object","entries","parseCookies","decode","value","name","get","compress","setCookie","cookieOptions","encode","httpOnly","walkState","subtrees","walker","stateA","stateB","produce","draftState","subtreeConfig","subtree","result","SERVE_COOKIES","store","cookies","ignoreStateFromStaticProps","path","sameSite","globalSubtreeConfig","map","current","processMiddlewareConfig","next","action","type","payload","allCookies","dispatch","HYDRATE","oldState","getState","newState","oldSubtreeState","newSubtreeState","isEqual","makeStore","undefined","ctx","isAppContext","req","res","isSsrContext"],"mappings":"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"}